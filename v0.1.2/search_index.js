var documenterSearchIndex = {"docs":
[{"location":"dependencies/#Dependencies","page":"Credits","title":"Dependencies","text":"YASS relies on several specialized external packages. These packages actively maintained and well trusted within the Julia ecosystem. If this changes, YASS will remove these dependencies and if necessary implement the specialized code in-house. Here the dependencies are listed with links to their repos to give credit to their work but also to provide transperancy.\n\nPackages within the Julia standard library are listed seperately since they are expected to be maintained as well as the Julia langague itself. For each dependency there is a short description of how it is used in YASS, or why it is considered for removal.\n\nJulia Standard Library Packages\n\nTOML:\nLibdl:\nStatistics:\nSerialization:\nLinearAlgebra:\n\nExternal Packages\n\nFFTW:\nOptim:\nPyCall:\nChemfiles:\nDistances:\nClustering:\nStaticArrays:\nDistributions:\nKernelDensity:\nOrdinaryDiffEq:\n\nConsidered for Removal\n\nJLD2: This package is currently only used to load neural network data for potentials. This functionality can be covered by the Serialization package, which can reduce the total dependency count. Note, this is a well maintained package and users are encouraged to use it alongside YASS.\nDataFrames: This package does not add any functionality to YASS, but rather enchances user exerpience. However, this can be achieved by users using the package alongside YASS, rather than it being a dependency. Note, this is a well maintained package and users are encouraged to use it alongside YASS.","category":"section"},{"location":"md/thermostats/#Thermostats","page":"Thermostats","title":"Thermostats","text":"YASS includes some pre-written thermostats for use in molecular dyunamics simulations. However, it is also fairly easy to create a custom thermostat to use in simulations. \n\nThe included thermostats are:\n\nBerendsen\nLangevin\nCanonical velocity rescaling","category":"section"},{"location":"md/thermostats/#Custom-Thermostat","page":"Thermostats","title":"Custom Thermostat","text":"Here the Berendsen thermostat is shown to illustrate how to create a custom thermostat. Custom thermostats require a struct for their parameters and an action function.\n\nstruct Berendsen{F<:AbstractFloat} <: ThermoVars\n  gamma::F\nend\n\n\"\"\"\nAction function\n\nRequired arguments:\n  a: accerleration of particles in system\n  v: velocity of particles in system\n  m: masses of particles in system\n  Tsim: the current simulation temperature\n  thermostat: the thermostat\n\nreturn nothing\n\nOrder must be preserved but u and vars can be named anything.\n\"\"\"\nfunction Berendsen!(a, v, m, Tsim, thermostat)\n  # Access our thermostat parameter gamma\n  gamma = thermostat.vars.gamma\n\n  # thermostat.T is the target temperature\n  if Tsim == 0.0\n    a .+= gamma .* v\n  else\n    a .+= gamma * (thermostat.T / Tsim - 1) .* v\n  end\nend\n\nNow that we have made all the necessary components we can put it all together as a thermostat.\n\n# Define a constructor for it passable temperature\nfunction Berendsen(T::F, gamma::F) where F<:AbstractFloat\n  Thermostat(T, Berendsen!, vars=Berendsen(gamma))\nend","category":"section"},{"location":"vibrations/#Vibrational-Analysis","page":"Vibrations","title":"Vibrational Analysis","text":"YASS provides multiple methods for analyzing vibrational properties of molecular systems:\n\nHarmonic frequency analysis\nVelocity autocorrelation function (VACF)","category":"section"},{"location":"vibrations/#Harmonic-Frequencies","page":"Vibrations","title":"Harmonic Frequencies","text":"The harmonic approximation calculates vibrational frequencies by diagonalizing the mass-weighted Hessian matrix:\n\nusing YetAnotherSimulationSuite\n\n# Read molecular structure\nmolecule = readSystem(\"water.xyz\")\n\n# Calculate frequencies and normal modes\nfreqs, modes = getHarmonicFreqs(TIP4Pf(), molecule)\n\nThe outputs are:\n\nfreqs: Vector of vibrational frequencies (in cm^-1)\nmodes: Matrix where each column is a normal mode eigenvector","category":"section"},{"location":"vibrations/#Analyzing-Normal-Modes","page":"Vibrations","title":"Analyzing Normal Modes","text":"You can visualize and analyze individual modes:\n\n# Get the first normal mode\nmode1 = modes[:,1]\n\n# Animate a specific mode\nanimateMode(molecule, mode1, \"mode1.xyz\", c=0.5)  # c controls amplitude\n\n# Calculate potential energy surface along mode\npes = getModePES(TIP4Pf(), molecule, mode1)","category":"section"},{"location":"vibrations/#Mode-Selection","page":"Vibrations","title":"Mode Selection","text":"For larger molecules, you can filter and analyze specific modes:\n\n# Find modes in a frequency range\nrange = 3000:4000  # OH stretch region\nidx = findall(f -> f in range, real.(freqs))\nstretch_modes = modes[:,idx]\n\n# Calculate mode participation ratios\npr = getPR(modes)  # Shows which atoms participate in each mode\n\n# Get inverse participation ratio\nipr = getIPR(modes)","category":"section"},{"location":"vibrations/#Velocity-Autocorrelation-Function-(VACF)","page":"Vibrations","title":"Velocity Autocorrelation Function (VACF)","text":"The VACF analyzes vibrational properties from MD trajectories:\n\nusing YetAnotherSimulationSuite\n\n# Run MD simulation\nmolecule = readSystem(\"water.xyz\")\ntraj = run(TIP4Pf(), molecule, (0.0u\"fs\", 10.0u\"ps\"), 1.0u\"fs\", NVE())\n\n# Extract velocities and masses\nvel, mas = getVelMas(traj)\n\n# Configure VACF calculation\ninp = vacfInps(\n    vel,       # Velocity trajectories\n    mas,       # Atomic masses\n    1e15u\"Hz\",  # Sampling frequency (1/fs = 1e15 Hz)\n    true,      # Normalize VACF\n    Hann,      # Window function\n    4,         # FFT padding factor\n    true       # Mirror the data\n)\n\n# Calculate VDOS\nout = VDOS(inp)","category":"section"},{"location":"vibrations/#VACF-Components","page":"Vibrations","title":"VACF Components","text":"The vacfOut structure contains:\n\nout.c: Raw velocity autocorrelation function\nout.C: Windowed/processed VACF\nout.v: Frequency axis (in cm^-1)\nout.I: Vibrational density of states","category":"section"},{"location":"vibrations/#Customizing-the-Analysis","page":"Vibrations","title":"Customizing the Analysis","text":"Several parameters can be adjusted:\n\n# Different window functions\ninp = vacfInps(vel, mas, 1e15u\"Hz\", true, Welch, 4, true)   # Welch window\ninp = vacfInps(vel, mas, 1e15u\"Hz\", true, HannM, 4, true)   # Modified Hann\n\n# Increased padding for better frequency resolution\ninp = vacfInps(vel, mas, 1e15u\"Hz\", true, Hann, 8, true)\n\n# Without mirroring\ninp = vacfInps(vel, mas, 1e15u\"Hz\", true, Hann, 4, false)","category":"section"},{"location":"vibrations/#Atom-Specific-Analysis","page":"Vibrations","title":"Atom-Specific Analysis","text":"You can analyze specific atoms or groups:\n\n# Analyze only oxygen atoms\nO_idx = findall(x -> x == \"O\", traj.symbols)\nout_O = VDOS(inp, atms=O_idx)\n\n# Analyze only hydrogen atoms\nH_idx = findall(x -> x == \"H\", traj.symbols)\nout_H = VDOS(inp, atms=H_idx)\n\n# Compare spectra\nusing Plots\nplot(out_O.v, out_O.I, label=\"Oxygen\", alpha=0.6)\nplot!(out_H.v, out_H.I, label=\"Hydrogen\", alpha=0.6)\nxlabel!(\"Wavenumber (cm-1)\")\nylabel!(\"VDOS\")","category":"section"},{"location":"vibrations/#Visualization","page":"Vibrations","title":"Visualization","text":"YASS provides several ways to visualize vibrational properties:\n\nusing Plots\n\n# Plot VDOS spectrum\nplot(out.v, out.I,\n     xlabel=\"Wavenumber (cm⁻¹)\",\n     ylabel=\"VDOS\",\n     label=\"Total\",\n     linewidth=2)\n\n# Plot raw VACF\nplot(out.c,\n     xlabel=\"Time\",\n     ylabel=\"VACF\",\n     label=\"Raw\")\n\n# Plot windowed VACF\nplot(out.C,\n     xlabel=\"Time\",\n     ylabel=\"VACF\",\n     label=\"Processed\")","category":"section"},{"location":"vibrations/#Tips-for-Quality-Results","page":"Vibrations","title":"Tips for Quality Results","text":"For harmonic analysis:\nEnsure structures are well-optimized\nUse tight convergence criteria\nFor VACF analysis:\nUse long enough trajectories (>10 ps)\nUse an appropriate timestep (depends on mode frequency)\nEnsure good energy conservation\nTest different window functions\nAdjust padding for desired resolution","category":"section"},{"location":"potentials/potList/#Available-Potentials","page":"Available Potentials","title":"Available Potentials","text":"YASS contains a few potentials.","category":"section"},{"location":"potentials/potList/#Leonard-Jones-Potential","page":"Available Potentials","title":"Leonard Jones Potential","text":"# Example vars for Au\nd = Dict(\n  \"epsilon\" => 0.2297,\n  \"sigma\" => 2.95,\n  \"rs\" => 19.0,\n  \"rc\" => 20.0\n)\n\ncalc = LJ(d)","category":"section"},{"location":"potentials/potList/#CO-Potentials","page":"Available Potentials","title":"CO Potentials","text":"","category":"section"},{"location":"potentials/potList/#MvHff","page":"Available Potentials","title":"MvHff","text":"Based on: van Hemert, Marc C., Junko Takahashi, and Ewine F. van Dishoeck. \"Molecular dynamics study of the photodesorption of CO ice.\" The Journal of Physical Chemistry A 119.24 (2015): 6354-6369.\n\nLink: https://pubs.acs.org/doi/full/10.1021/acs.jpca.5b02611\n\ncalc = MvHff()","category":"section"},{"location":"potentials/potList/#HGNN","page":"Available Potentials","title":"HGNN","text":"Based on: Chen, Jun, et al. \"Energy transfer between vibrationally excited carbon monoxide based on a highly accurate six-dimensional potential energy surface.\" The  Journal of Chemical Physics 153.5 (2020).\n\nLink: https://pubs.aip.org/aip/jcp/article/153/5/054310/1065758\n\ncalc = HGNN()","category":"section"},{"location":"potentials/potList/#H_2O-Potentials","page":"Available Potentials","title":"H_2O Potentials","text":"","category":"section"},{"location":"potentials/potList/#TIP4P/2005f","page":"Available Potentials","title":"TIP4P/2005f","text":"Based on: González, M. A., & Abascal, J. L. (2011). A flexible model for water based on TIP4P/2005. The Journal of chemical physics, 135(22).\n\nLink: https://pubs.aip.org/aip/jcp/article/135/22/224516/190786\n\ncalc = TIP4Pf()","category":"section"},{"location":"potentials/potList/#Simple-Point-Charge-Models","page":"Available Potentials","title":"Simple Point Charge Models","text":"","category":"section"},{"location":"potentials/potList/#SPC/F","page":"Available Potentials","title":"SPC/F","text":"Based on: Toukan, Kahled, and Aneesur Rahman. \"Molecular-dynamics study of atomic motions in water.\" Physical Review B 31.5 (1985): 2643.\n\nLink: https://journals.aps.org/prb/abstract/10.1103/PhysRevB.31.2643\n\ncalc = SPC(\"SPC/F\")","category":"section"},{"location":"potentials/potList/#SPC/Fd","page":"Available Potentials","title":"SPC/Fd","text":"Based on: Dang, Liem X., and B. Montgomery Pettitt. \"Simple intramolecular model potentials for water.\" Journal of physical chemistry 91.12 (1987): 3349-3354.\n\nLink: https://doi.org/10.1021/j100296a048\n\ncalc = SPC(\"SPC/Fd\")","category":"section"},{"location":"potentials/potList/#SPC/Fw","page":"Available Potentials","title":"SPC/Fw","text":"Based on: Wu, Yujie, Harald L. Tepper, and Gregory A. Voth. \"Flexible simple point-charge water model with improved liquid-state properties.\" The Journal of chemical physics 124.2 (2006).\n\nLink: https://doi.org/10.1063/1.2136877\n\ncalc = SPC(\"SPC/Fw\")","category":"section"},{"location":"potentials/customPot/#Custom-Potentials","page":"Custom Potentials","title":"Custom Potentials","text":"YASS allows you to implement custom potentials for molecular simulations. This guide demonstrates how to create a custom potential using a Lennard-Jones potential for gold (Au) as an example. To create a custom potential, you need three components:\n\nPotVars struct - Holds potential parameters\nInitializer function - Sets up the potential\nEvaluation functions - Calculate energies and forces\n\nusing YetAnotherSimulationSuite\n\nstruct AuLJPotVars{F<:Float64} <: PotVars\n    ε::F    # Well depth (eV)\n    σ::F    # Equilibrium distance (Å)\n    rc::F   # Cutoff radius (Å)\n    rc2::F  # Squared cutoff (Å²)\nend\n\n# Initialize potential with Au parameters\nfunction AuLJPotential(x::Union{Vector{MyAtoms}, MyCell})\n    ε = 5.29e-3  # eV\n    σ = 2.951    # Å (minimum at 2^(1/6)σ ≈ 3.31Å)\n    rc = 8.0     # Å\n    rc2 = rc^2   # Precalculate squared cutoff\n    \n    AuLJPotVars(ε, σ, rc, rc2)\nend\n\n# Energy-only evaluation\nfunction AuLJEnergy(u, vars)\n    E = 0.0\n    potVars = vars.potVars\n    \n    # Extract parameters\n    ε = potVars.ε\n    σ = potVars.σ\n    rc2 = potVars.rc2\n    \n    # Calculate pair interactions\n    for i = 1:length(u)\n        for j = i+1:length(u)\n            \n            # Get distance vector and magnitude squared\n            r = u[j] - u[i]\n            r2 = dot(r, r)\n            \n            # Skip if beyond cutoff\n            r2 > rc2 && continue\n            \n            # Calculate LJ terms\n            σ_r2 = (σ^2)/r2\n            σ_r6 = σ_r2^3\n            σ_r12 = σ_r6^2\n            \n            # Add pair energy\n            E += 4ε*(σ_r12 - σ_r6)\n        end\n    end\n    \n    E\nend\n\n# Force-only evaluation (in-place)\nfunction AuLJForces!(F, u, vars)\n    potVars = vars.potVars\n    \n    # Extract parameters\n    ε = potVars.ε\n    σ = potVars.σ\n    rc2 = potVars.rc2\n    \n    # Calculate forces between pairs\n    for i = 1:length(u)\n        for j = i+1:length(u)\n            \n            # Get distance vector and magnitude squared\n            r = u[j] - u[i]\n            r2 = dot(r, r)\n            \n            # Skip if beyond cutoff\n            r2 > rc2 && continue\n            \n            # Calculate LJ terms\n            σ_r2 = (σ^2)/r2\n            σ_r6 = σ_r2^3\n            σ_r12 = σ_r6^2\n            \n            # Calculate force (negative gradient)\n            f = 24ε/r2 * (2σ_r12 - σ_r6) .* r\n            \n            # Add forces\n            F[i] .-= f\n            F[j] .+= f\n        end\n    end\nend\n\n# Combined energy and forces evaluation\nfunction AuLJEnergyForces!(F, u, vars)\n    E = 0.0\n    potVars = vars.potVars\n    \n    # Extract parameters\n    ε = potVars.ε\n    σ = potVars.σ\n    rc2 = potVars.rc2\n    \n    # Calculate interactions\n    for i = 1:length(u)\n        for j = i+1:length(u)\n            \n            # Get distance vector and magnitude squared\n            r = u[j] - u[i]\n            r2 = dot(r, r)\n            \n            # Skip if beyond cutoff\n            r2 > rc2 && continue\n            \n            # Calculate LJ terms\n            σ_r2 = (σ^2)/r2\n            σ_r6 = σ_r2^3\n            σ_r12 = σ_r6^2\n            \n            # Add pair energy\n            E += 4ε*(σ_r12 - σ_r6)\n            \n            # Calculate and add forces\n            f = 24ε/r2 * (2σ_r12 - σ_r6) .* r\n            F[i] .-= f\n            F[j] .+= f\n        end\n    end\n    \n    E\nend\n\n# Initializer function\nfunction AuLJ(; constraints=nothing)\n    Calculator(\n        AuLJPotential;\n        E = AuLJEnergy,\n        F = AuLJForces!,\n        EF = AuLJEnergyForces!,\n        constraints=constraints\n    )\nend","category":"section"},{"location":"potentials/customPot/#Usage-example","page":"Custom Potentials","title":"Usage example","text":"# Create gold cluster\natoms::Vector{MyAtoms} = [\n    Particle([0.0, 0.0, 0.0], zeros(3), 196.97, \"Au\"),\n    Particle([3.0, 0.0, 0.0], zeros(3), 196.97, \"Au\"),\n    Particle([0.0, 3.0, 0.0], zeros(3), 196.97, \"Au\")\n]\n\n# Create calculator\ncalc = AuLJ()\n\n# Get energy\nE = getPotEnergy(calc, atoms)\nprintln(\"Potential energy: $E eV\")\n\n# Get forces\nF = getForces(calc, atoms)\nprintln(\"Forces on first atom: $(F[1]) eV/Å\")\n\n# Run MD simulation\ntraj = run(calc, atoms, (0.0, 10.0ps), 1.0fs, NVE())\nprintln(\"Trajectory length: $(length(traj)) frames\")","category":"section"},{"location":"potentials/customPot/#Key-Points-About-Custom-Potentials","page":"Custom Potentials","title":"Key Points About Custom Potentials","text":"Parameter Storage\nUse PotVars to store constants and parameters\nPrecalculate frequently used values (like rc²)\nInclude units in comments for clarity\nForce Calculations\nUse in-place operations with F[i] .-= f style updates\nOptimization Tips\nImplement distance cutoffs for efficiency\nPrecalculate squared terms where possible\nUse inplace operations and buffers to reduce memory allocations\nGood Practices\nInclude references for potential parameters\nDocument units clearly\nImplement all three evaluation functions for flexibility\nTest energy conservation in MD simulations\n\nFor more examples, check the source code of built-in potentials in YASS.","category":"section"},{"location":"optimizations/#Geometry-Optimizations","page":"Optimization","title":"Geometry Optimizations","text":"YASS provides geometry optimization capabilities through Optim.jl. This section explains how to optimize molecular structures and crystal cells.","category":"section"},{"location":"optimizations/#Basic-Usage","page":"Optimization","title":"Basic Usage","text":"The simplest way to optimize a molecular structure is:\n\nusing Optim\nusing YetAnotherSimulationSuite\n\n# Read initial structure\nmolecule = readSystem(\"water.xyz\")\n\n# Run geometry optimization\noptimized = opt(TIP4Pf(), LBFGS(), molecule)\n\n# Save optimized structure\nwrite(\"optimized.xyz\", optimized)","category":"section"},{"location":"optimizations/#Optimization-Algorithms","page":"Optimization","title":"Optimization Algorithms","text":"YASS optimizations can be done with any optimizer in Optim.jl\n\nusing Optim\nusing YetAnotherSimulationSuite\n\n# Using algorithms directly from Optim\nopt(calc, LBFGS(), molecule)\nopt(calc, ConjugateGradient(), molecule)\nopt(calc, OACCEL(), molecule)","category":"section"},{"location":"optimizations/#Configuring-Optimizations","page":"Optimization","title":"Configuring Optimizations","text":"The opt function accepts several keyword arguments to control the optimization:\n\noptimized = opt(\n    TIP4Pf(),           # Calculator\n    LBFGS(),            # Algorithm\n    molecule;           # Structure\n    f_abstol=1e-8,      # Function value tolerance\n    g_abstol=1e-5,      # Gradient tolerance  \n    iterations=100_000, # Maximum iterations\n    show_trace=true     # Show progress\n)\n\nCommon optimization parameters:\n\nf_abstol: Tolerance for changes in energy (default: 0.0)\ng_abstol: Tolerance for forces/gradients (default: 1e-8)\niterations: Maximum optimization steps (default: 1000)\nshow_trace: Display optimization progress (default: false)","category":"section"},{"location":"optimizations/#Periodic-Systems","page":"Optimization","title":"Periodic Systems","text":"For periodic systems, use a Cell object:\n\n# Read periodic structure\ncrystal = readSystem(\"crystal.xyz\")\n\n# Optimize atomic positions only\noptimized = opt(calc, LBFGS(), crystal)\n\n# Optimize cell parameters (lattice vectors)\noptimized = optCell(calc, LBFGS(), crystal)","category":"section"},{"location":"optimizations/#Constraints","page":"Optimization","title":"Constraints","text":"You can apply constraints during optimization:\n\n# Fix specific atoms (by index)\nfixed = FixedAtoms([1,2,3])\ncalc = Calculator(TIP4Pf(); constraints=[fixed])\n\n# Run constrained optimization\noptimized = opt(calc, LBFGS(), molecule)","category":"section"},{"location":"optimizations/#Convergence-Monitoring","page":"Optimization","title":"Convergence Monitoring","text":"To monitor optimization progress:\n\noptimized = opt(\n    calc, LBFGS(), molecule;\n    show_trace=true,\n    extended_trace=true,  # Show detailed info\n    trace_simplex=true    # For Nelder-Mead\n)","category":"section"},{"location":"optimizations/#Advanced-Usage","page":"Optimization","title":"Advanced Usage","text":"For more control over the optimization:\n\n# Custom convergence criteria\noptimized = opt(\n    calc, LBFGS(), molecule;\n    x_tol=1e-6,        # Position tolerance\n    f_calls_limit=1000, # Max energy evaluations\n    g_calls_limit=1000  # Max gradient evaluations\n)\n\n# Use different line search method\noptimized = opt(\n    calc, LBFGS(), molecule;\n    linesearch=LineSearches.BackTracking()\n)\n\nFor additional options and algorithms, refer to the Optim.jl documentation.","category":"section"},{"location":"bodies/#Simulation-Bodies","page":"Bodies","title":"Simulation Bodies","text":"YASS provides two main types of simulation objects: Particle and Cell. Each serves different purposes in molecular simulations:\n\nParticle: Represents individual atoms or particles\nCell: Represents periodic systems like crystals\n\nSeveral xyz files of different molecules, small clusters and periodic cells can be found in the testing directory of the main repo. These can be used as dummy systems to play with while learning how to use YASS.\n\nnote: Visualizing Simulations\nYASS does not have visualization functionality, however, many third-party apps can visualize the files YASS writes. Check out the following options:     - ASE      - Jmol     - VMD     - Blender (higher compelexity)","category":"section"},{"location":"bodies/#Particle-Objects","page":"Bodies","title":"Particle Objects","text":"The Particle type is the fundamental building block for molecular simulations. Each particle has:\n\nPosition vector (r)\nVelocity vector (v) \nMass (m)\nChemical symbol (s)","category":"section"},{"location":"bodies/#Creating-Particles","page":"Bodies","title":"Creating Particles","text":"You can create particles in several ways:\n\nusing YetAnotherSimulationSuite\n\n# Read from XYZ file\natoms = readSystem(\"molecule.xyz\")\n\n# Create manually\nwater::Vector{MyAtoms} = [\n    Particle([0.000,  0.000, 0.000], zeros(3), 15.999, \"O\"),\n    Particle([0.757,  0.586, 0.000], zeros(3),  1.008, \"H\"),\n    Particle([0.757, -0.586, 0.000], zeros(3),  1.008, \"H\")\n]\n\n# Save to file\nwrite(\"water.xyz\", water)","category":"section"},{"location":"bodies/#Modifying-Particles","page":"Bodies","title":"Modifying Particles","text":"The Particle type is mutable, allowing modifications after creation:\n\n# Modify position\natoms[1].r .= [1.0, 0.0, 0.0]\n\n# Change velocity\natoms[1].v .= [0.1, 0.0, 0.0]\n\n# Update mass (e.g., for isotope studies)\natoms[1].m = 18.015  # Change to heavy water\n\n# Change chemical symbol\natoms[1].s = \"D\"     # Deuterium","category":"section"},{"location":"bodies/#Particle-Manipulation-Functions","page":"Bodies","title":"Particle Manipulation Functions","text":"YASS provides several utility functions for working with particles:\n\n# Translate all particles\ntranslate!(atoms, [1.0, 0.0, 0.0])\n\n# Center particles at origin\ncenterBdys!(atoms)\n\n# Swap positions of two particles\nswapAtoms!(atoms, 1, 2)\n\n# Change isotopes for specific atoms\nswapIso!(atoms, [1,2], [2.014, 2.014])  # Convert H to D\n\n# Get center of mass\ncom = CoM(atoms)\n\n# Get center of mass velocity\nvcom = vCoM(atoms)\n\n# Remove center of mass motion\nzeroVCoM!(atoms)","category":"section"},{"location":"bodies/#Cell-Objects","page":"Bodies","title":"Cell Objects","text":"The Cell type represents periodic systems and contains:\n\nLattice matrix\nScaled positions (fractional coordinates)\nVelocities\nMasses\nChemical symbols  \nPeriodic boundary conditions\nNeighbor counts","category":"section"},{"location":"bodies/#Creating-Cells","page":"Bodies","title":"Creating Cells","text":"using YetAnotherSimulationSuite\n\n# Read from file with lattice information\ncell = readSystem(\"crystal.xyz\")\n\n# Create from atoms and lattice\natoms = [\n    Particle([0.0, 0.0, 0.0], zeros(3), 22.990, \"Na\"),\n    Particle([0.5, 0.5, 0.5], zeros(3), 35.450, \"Cl\")\n]\nlattice = [\n    5.0 0.0 0.0\n    0.0 5.0 0.0\n    0.0 0.0 5.0\n]\ncell = makeCell(atoms, lattice)\n\n# Specify periodic boundary conditions\ncell = makeCell(atoms, lattice, \n    PBC=[true, true, true],  # Periodic in all directions\n    NC=[1,1,1]               # Neighbor cells to consider\n)\n\n# Save cell to file\nwrite(\"nacl.xyz\", cell)","category":"section"},{"location":"bodies/#Cell-Operations","page":"Bodies","title":"Cell Operations","text":"YASS provides various functions for cell manipulation:\n\n# Wrap atoms back into primary cell\nwrap!(cell)\n\n# Center atoms in cell\ncenter!(cell)\n\n# Create supercell\ntransform = [2 0 0; 0 2 0; 0 0 2]  # 2x2x2 supercell\nsuper = makeSuperCell(cell, transform)\n\n# Convert between cell and atoms\natoms = makeBdys(cell)        # Cell -> Atoms\ncell = makeCell(atoms, lat)   # Atoms -> Cell\n\n# Get Cartesian positions\npositions = getPos(cell)\n\n# Get cell volume\nvolume = getVolume(cell)\n\n# Reorder atoms\norder = sortperm([atom.m for atom in atoms])\nreorder!(cell, order)","category":"section"},{"location":"api/#YetAnotherSimulationSuite.YetAnotherSimulationSuite","page":"API","title":"YetAnotherSimulationSuite.YetAnotherSimulationSuite","text":"YetAnotherSimulationSuite.jl (YASS)\n\nA simulation suite for molecular dynamics in Julia. \n\n\n\n\n\n","category":"module"},{"location":"api/#YetAnotherSimulationSuite.Calculator","page":"API","title":"YetAnotherSimulationSuite.Calculator","text":"Calculator\n\nStructure for a calculator object for MD.\n\nFields\n\nb: Potential builder.\ne: Energy function.\nf!: Force function.\nef!: Energy and force function.\nenergy_unit: Unitful energy unit\nforce_unit: Unitful force unit\ntime_unit: Unitful time unit\nconstraints: Constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/#YetAnotherSimulationSuite.Calculator-NTuple{4, Any}","page":"API","title":"YetAnotherSimulationSuite.Calculator","text":"Calculator(b; E=nothing, F=nothing, EF=nothing, constraints=nothing)\n\nConstruct a Calculator object.\n\nArguments\n\nb: Potential builder.\nE: Energy function (optional).\nF: Force function (optional).\nEF: Energy and force function (optional).\nconstraints: Constraints (optional).\n\nReturns\n\nCalculator object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.Cell","page":"API","title":"YetAnotherSimulationSuite.Cell","text":"Cell{D, B, I, F, S}\n\nStructure representing a simulation cell.\n\nFields\n\nlattice: Lattice matrix.\nscaled_pos: Scaled positions.\nvelocity: Velocities.\nmasses: Masses.\nsymbols: Atomic symbols.\nmask: Mask vector.\nPBC: Periodic boundary conditions.\nNC: Neighbor counts.\n\n\n\n\n\n","category":"type"},{"location":"api/#YetAnotherSimulationSuite.Cell-Union{Tuple{S}, Tuple{F}, Tuple{Matrix, AbstractArray, AbstractArray, Vector{F}, Vector{S}, Vector{Bool}, Vector{Bool}, Vector{Int64}}} where {F<:AbstractFloat, S<:AbstractString}","page":"API","title":"YetAnotherSimulationSuite.Cell","text":"Cell(lat, spos, vel, mas, sym, mask, PBC, NC)\n\nConstruct a Cell object from lattice, positions, velocities, etc.\n\nArguments\n\nlat: Lattice matrix.\nspos: Scaled positions.\nvel: Velocities.\nmas: Masses.\nsym: Symbols.\nmask: Mask vector.\nPBC: Periodic boundary conditions.\nNC: Neighbor counts.\n\nReturns\n\nCell object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.Dynamics","page":"API","title":"YetAnotherSimulationSuite.Dynamics","text":"Dynamics{T,D,B,P,PV,I,F,S}\n\nStructure holding all MD simulation variables.\n\nFields\n\nm: Masses.\ns: Symbols.\nmols: Molecule indices.\ntemp: Temperatures.\nenergy: Energies.\nforces: Forces.\npotVars: Potential variables.\nPBC: Periodic boundary conditions.\nNC: Neighbor counts.\nensemble: Ensemble object.\n\n\n\n\n\n","category":"type"},{"location":"api/#YetAnotherSimulationSuite.HiddenOptVars","page":"API","title":"YetAnotherSimulationSuite.HiddenOptVars","text":"HiddenOptVars\n\nStructure for hidden variable optimization.\n\nFields\n\npotVars: Potential variables.\ncellBuf: Cell buffer.\nsuperBuf: Supercell buffer.\nscaleEnergy: Energy scaling factor.\nPBC: Periodic boundary conditions.\nmols: Molecule indices.\npars: Pair indices.\nT: Transformation matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/#YetAnotherSimulationSuite.NVE-Tuple{MyCell}","page":"API","title":"YetAnotherSimulationSuite.NVE","text":"NVE(cell::MyCell)\n\nConstruct an NVE ensemble from a MyCell object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.NVE-Tuple{}","page":"API","title":"YetAnotherSimulationSuite.NVE","text":"NVE()\n\nConstruct a default NVE ensemble with zero lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.NVT","page":"API","title":"YetAnotherSimulationSuite.NVT","text":"NVT{D,T,F}\n\nStructure for NVT (canonical) ensemble.\n\nFields\n\nlattice: Lattice matrix.\nthermostat: Thermostat object.\n\n\n\n\n\n","category":"type"},{"location":"api/#YetAnotherSimulationSuite.NVT-Tuple{MyCell, MyThermostat}","page":"API","title":"YetAnotherSimulationSuite.NVT","text":"NVT(cell::MyCell, thermostat::MyThermostat)\n\nConstruct an NVT ensemble from a MyCell and thermostat.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.NVT-Tuple{MyThermostat}","page":"API","title":"YetAnotherSimulationSuite.NVT","text":"NVT(thermostat::MyThermostat)\n\nConstruct an NVT ensemble with zero lattice and given thermostat.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.Particle","page":"API","title":"YetAnotherSimulationSuite.Particle","text":"Particle{D, F, S}\n\nMutable struct representing an atom in the simulation.\n\nFields\n\nr: Position vector.\nv: Velocity vector.\nm: Mass.\ns: Symbol.\n\n\n\n\n\n","category":"type"},{"location":"api/#YetAnotherSimulationSuite.Particle-Union{Tuple{V}, Tuple{V, V, Float64, String}} where V<:Union{Vector, StaticArraysCore.SVector}","page":"API","title":"YetAnotherSimulationSuite.Particle","text":"Particle(r, v, m, s)\n\nConstruct a Particle from position, velocity, mass, and symbol.\n\nArguments\n\nr: Position vector.\nv: Velocity vector.\nm: Mass.\ns: Symbol.\n\nReturns\n\nParticle object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.Traj-Union{Tuple{T}, Tuple{T, Vector{Float64}, Vector{String}, Union{Matrix, StaticArraysCore.MMatrix}}} where T","page":"API","title":"YetAnotherSimulationSuite.Traj","text":"Traj(imgs, mas, sym, lat)\n\nConstruct a Traj object from images, masses, symbols, and lattice.\n\nArguments\n\nimgs: Vector of Image objects.\nmas: Vector of masses.\nsym: Vector of symbols.\nlat: Lattice matrix.\n\nReturns\n\nTraj object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.optVars","page":"API","title":"YetAnotherSimulationSuite.optVars","text":"optVars\n\nStructure holding optimization variables for geometry optimization.\n\nFields\n\npotVars: Potential variables.\nmols: Molecule indices.\nm: Masses.\nPBC: Periodic boundary conditions.\nNC: Neighbor counts.\nlattice: Lattice matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/#YetAnotherSimulationSuite.vacfInps","page":"API","title":"YetAnotherSimulationSuite.vacfInps","text":"vacfInps\n\nInput structure for velocity autocorrelation function (VACF) calculations.\n\nFields\n\nvel: Velocity data.\nmas: Masses.\nHz: Sampling frequency.\nnorm: Normalize flag.\nwin: Window function.\npad: Padding factor.\nmir: Mirror flag.\n\n\n\n\n\n","category":"type"},{"location":"api/#YetAnotherSimulationSuite.vacfOut","page":"API","title":"YetAnotherSimulationSuite.vacfOut","text":"vacfOut\n\nOutput structure for VACF and VDOS calculations.\n\nFields\n\nc: Raw VACF.\nC: Windowed VACF.\nv: Frequency axis.\nI: Intensity.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.deleteat!-Tuple{MyCell, Any}","page":"API","title":"Base.deleteat!","text":"deleteat!(cell::MyCell, iter)\n\nRemove atoms at given indices from a cell.\n\nArguments\n\ncell: MyCell object.\niter: Indices to remove.\n\nSide Effects\n\nModifies the cell in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{MyCell, Any}","page":"API","title":"Base.getindex","text":"getindex(cell::MyCell, inds)\n\nGet cell atoms at inds indicies\n\nArguments\n\ncell: MyCell object\ninds: Indices to get\n\nReturns\n\nCell object\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{MyCell}","page":"API","title":"Base.length","text":"length(cell::MyCell)\n\nGet number of atoms in cell\n\nArguments\n\ncell: MyCell object\n\nReturns\n\nNumber of atoms in cell\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{MyTraj}","page":"API","title":"Base.length","text":"length(traj::MyTraj)\n\nGet the number of images in a trajectory.\n\nArguments\n\ntraj: Traj object.\n\nReturns\n\nNumber of images.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Tuple{MyTraj, SciMLBase.ODESolution, Float64}","page":"API","title":"Base.push!","text":"push!(tj::MyTraj, solu::SciMLBase.ODESolution; dt=fs, step=1)\n\nAppend images from an ODE solution to a trajectory.\n\nArguments\n\ntj: Traj object.\nsolu: ODE solution object.\ndt: Time step (default: fs).\nstep: Step interval (default: 1).\n\nSide Effects\n\nModifies tj in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.repeat-Tuple{MyCell, Integer}","page":"API","title":"Base.repeat","text":"repeat(cell::MyCell, count::Integer)\n\nRepeat a cell multiple times.\n\nArguments\n\ncell: MyCell object.\ncount: Number of repetitions.\n\nReturns\n\nNew repeated Cell object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.run-Union{Tuple{T}, Tuple{MyCalc, MyCell, Quantity, Quantity, T}} where T<:Union{NVE, NVT, YetAnotherSimulationSuite.NpT}","page":"API","title":"Base.run","text":"run(calc, cell, tmax, dt, ensemble; algo=VelocityVerlet(), split=1, kwargs...)\n\nRun an MD simulation for a cell.\n\nArguments\n\ncalc: Calculator object.\ncell: MyCell object.\ntmax: Time span tuple.\ndt: Time step.\nensemble: Ensemble object.\nalgo: ODE solver algorithm (default: VelocityVerlet()).\nsplit: Number of segments (default: 1).\nkwargs: Additional keyword arguments.\n\nReturns\n\nProcessed trajectory or solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.run-Union{Tuple{T}, Tuple{MyCalc, MyCell, Tuple{Quantity, Quantity}, Quantity, T}} where T<:Union{NVE, NVT, YetAnotherSimulationSuite.NpT}","page":"API","title":"Base.run","text":"run(calc, cell, tspan, dt, ensemble; algo=VelocityVerlet(), split=1, kwargs...)\n\nRun an MD simulation for a cell.\n\nArguments\n\ncalc: Calculator object.\ncell: MyCell object.\ntspan: Time span tuple.\ndt: Time step.\nensemble: Ensemble object.\nalgo: ODE solver algorithm (default: VelocityVerlet()).\nsplit: Number of segments (default: 1).\nkwargs: Additional keyword arguments.\n\nReturns\n\nProcessed trajectory or solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.run-Union{Tuple{T}, Tuple{MyCalc, Vector{MyAtoms}, Quantity, Quantity, T}} where T<:Union{NVE, NVT, YetAnotherSimulationSuite.NpT}","page":"API","title":"Base.run","text":"run(calc, bdys, tmax, dt, ensemble; algo=VelocityVerlet(), split=1, kwargs...)\n\nRun an MD simulation for a set of atoms.\n\nArguments\n\ncalc: Calculator object.\nbdys: Vector of MyAtoms.\ntmax: Time length of simulation.\ndt: Time step.\nensemble: Ensemble object.\nalgo: ODE solver algorithm (default: VelocityVerlet()).\nsplit: Number of segments (default: 1).\nkwargs: Additional keyword arguments.\n\nReturns\n\nProcessed trajectory or solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.run-Union{Tuple{T}, Tuple{MyCalc, Vector{MyAtoms}, Tuple{Quantity, Quantity}, Quantity, T}} where T<:Union{NVE, NVT, YetAnotherSimulationSuite.NpT}","page":"API","title":"Base.run","text":"run(calc, bdys, tspan, dt, ensemble; algo=VelocityVerlet(), split=1, kwargs...)\n\nRun an MD simulation for a set of atoms.\n\nArguments\n\ncalc: Calculator object.\nbdys: Vector of MyAtoms.\ntspan: Time span tuple.\ndt: Time step.\nensemble: Ensemble object.\nalgo: ODE solver algorithm (default: VelocityVerlet()).\nsplit: Number of segments (default: 1).\nkwargs: Additional keyword arguments.\n\nReturns\n\nProcessed trajectory or solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO, MyCell}","page":"API","title":"Base.show","text":"show(io::IO, cell::MyCell)\n\nDisplay cell struct information\n\nArguments\n\nio: IO \ncell: MyCell object\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO, MyTraj}","page":"API","title":"Base.show","text":"show(io::IO, traj::MyTraj)\n\nCustom display for MyTraj objects.\n\nArguments\n\nio: IO stream.\ntraj: MyTraj object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.write-Tuple{String, MyCell}","page":"API","title":"Base.write","text":"Base.write(file::String, cell::MyCell)\n\nWrite a MyCell object to a file using Chemfiles.\n\nArguments\n\nfile: Output file path.\ncell: MyCell object to write.\n\nSide Effects\n\nWrites atomic coordinates, velocities, and cell information to file.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.write-Tuple{String, MyTraj}","page":"API","title":"Base.write","text":"Base.write(file::String, traj::MyTraj; step=1)\n\nWrite a trajectory to a file using Chemfiles.\n\nArguments\n\nfile: Output file path.\ntraj: MyTraj object to write.\nstep: Step interval for writing frames (default: 1).\n\nSide Effects\n\nWrites trajectory frames, including positions, velocities, energies, and forces, to file.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.write-Tuple{String, Vector{MyAtoms}}","page":"API","title":"Base.write","text":"Base.write(file::String, bdys::Vector{MyAtoms})\n\nWrite a vector of MyAtoms to a file using Chemfiles.\n\nArguments\n\nfile: Output file path.\nbdys: Vector of MyAtoms to write.\n\nSide Effects\n\nWrites atomic coordinates and velocities to file.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.rotate!-Tuple{Vector{MyAtoms}, Matrix, Vector{Float64}}","page":"API","title":"LinearAlgebra.rotate!","text":"LinearAlgebra.rotate!(bdys::Vector{MyAtoms}, R::Matrix, about::Vector{Float64})\n\nRotate all atoms in bdys by rotation matrix R about a point about in-place.\n\nArguments\n\nbdys: Vector of MyAtoms objects.\nR: 3x3 rotation matrix.\nabout: Point to rotate about.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.rotate!-Tuple{Vector{MyAtoms}, Matrix}","page":"API","title":"LinearAlgebra.rotate!","text":"LinearAlgebra.rotate!(bdys::Vector{MyAtoms}, R::Matrix)\n\nRotate all atoms in bdys by rotation matrix R in-place.\n\nArguments\n\nbdys: Vector of MyAtoms objects.\nR: 3x3 rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.rotate!-Union{Tuple{F}, Tuple{Vector{MyAtoms}, Tuple{F, F, F}, Vector{F}}} where F<:AbstractFloat","page":"API","title":"LinearAlgebra.rotate!","text":"LinearAlgebra.rotate!(bdys::Vector{MyAtoms}, abc::Tuple{F,F,F}, about::Vector{F}) where F<:AbstractFloat\n\nRotate all atoms in bdys by Euler angles (α, β, γ) about a point about in-place.\n\nArguments\n\nbdys: Vector of MyAtoms objects.\nabc: Tuple of Euler angles (α, β, γ) in radians.\nabout: Point to rotate about.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.rotate!-Union{Tuple{F}, Tuple{Vector{MyAtoms}, Tuple{F, F, F}}} where F<:AbstractFloat","page":"API","title":"LinearAlgebra.rotate!","text":"LinearAlgebra.rotate!(bdys::Vector{MyAtoms}, abc::Tuple{F,F,F}) where F <: AbstractFloat\n\nRotate all atoms in bdys by Euler angles (α, β, γ) in-place.\n\nArguments\n\nbdys: Vector of MyAtoms objects.\nabc: Tuple of Euler angles (α, β, γ) in radians.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.CoM-Tuple{Any, Any}","page":"API","title":"YetAnotherSimulationSuite.CoM","text":"CoM(pos, mas)\n\nCompute the center of mass from positions and masses.\n\nArguments\n\npos: Vector of position vectors.\nmas: Vector of masses.\n\nReturns\n\nCenter of mass as a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.CoM-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.CoM","text":"CoM(bdys)\n\nCompute the center of mass for a collection of atoms.\n\nArguments\n\nbdys: Vector of objects with fields m (mass) and r (position).\n\nReturns\n\nCenter of mass as a 3-element vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.HGNN-Tuple{}","page":"API","title":"YetAnotherSimulationSuite.HGNN","text":"CO-CO Potential\n\nBased on: Chen, Jun, et al. \"Energy transfer between vibrationally excited carbon monoxide based on a highly accurate six-dimensional potential energy surface.\" The  Journal of Chemical Physics 153.5 (2020).\n\nLink: https://pubs.aip.org/aip/jcp/article/153/5/054310/1065758\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.LJ-Tuple{Dict}","page":"API","title":"YetAnotherSimulationSuite.LJ","text":"Lennard Jones potential\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.MBX-Tuple{}","page":"API","title":"YetAnotherSimulationSuite.MBX","text":"MBX potentials\n\nThis allows uing all the potentials found within the MBX package.\n\nMBX GitHub: https://github.com/paesanilab/MBX/tree/master\n\nMBX Paper: https://pubs.aip.org/aip/jcp/article/159/5/054802/2904909/MBX-A-many-body-energy-and-force-calculator-for\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.MvHff-Tuple{}","page":"API","title":"YetAnotherSimulationSuite.MvHff","text":"CO-CO Potential\n\nBased on: van Hemert, Marc C., Junko Takahashi, and Ewine F. van Dishoeck. \"Molecular dynamics study of the photodesorption of CO ice.\" The Journal of Physical Chemistry A 119.24 (2015): 6354-6369.\n\nLink: https://pubs.acs.org/doi/full/10.1021/acs.jpca.5b02611\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.SCMEf-Tuple{}","page":"API","title":"YetAnotherSimulationSuite.SCMEf","text":"SCME/f potential \n\nThis calls an ASE calculator of the SCME/f potential (not great) I still want to make a better wrapper. Idealy, one that calls the c++ routines directly (like MBX).\n\nSCME Paper: https://pubs.rsc.org/en/content/articlehtml/2013/cp/c3cp52097h\n\nSCME/f Paper: https://pubs.acs.org/doi/full/10.1021/acs.jctc.2c00598\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.SPC-Tuple{String}","page":"API","title":"YetAnotherSimulationSuite.SPC","text":"Simple Point Charge (SPC) Models\n\nSPC/F\n\nBased on: Toukan, Kahled, and Aneesur Rahman. \"Molecular-dynamics study of atomic motions in water.\" Physical Review B 31.5 (1985): 2643.\n\nLink: https://journals.aps.org/prb/abstract/10.1103/PhysRevB.31.2643\n\nSPC/Fd\n\nBased on: Dang, Liem X., and B. Montgomery Pettitt. \"Simple intramolecular model potentials for water.\" Journal of physical chemistry 91.12 (1987): 3349-3354.\n\nLink: https://doi.org/10.1021/j100296a048\n\nSPC/Fw\n\nBased on: Wu, Yujie, Harald L. Tepper, and Gregory A. Voth. \"Flexible simple point-charge water model with improved liquid-state properties.\" The Journal of chemical physics 124.2 (2006).\n\nLink: https://doi.org/10.1063/1.2136877\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.TIP4Pf-Tuple{}","page":"API","title":"YetAnotherSimulationSuite.TIP4Pf","text":"TIP4P/2005f \n\nBased on: González, M. A., & Abascal, J. L. (2011). A flexible model for water based on TIP4P/2005. The Journal of chemical physics, 135(22).\n\nLink: https://pubs.aip.org/aip/jcp/article/135/22/224516/190786\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.VDOS-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.VDOS","text":"VDOS(inp; atms=nothing)\n\nCompute the vibrational density of states (VDOS) from VACF input.\n\nArguments\n\ninp: vacfInps object.\natms: (Optional) Indices of atoms to include.\n\nReturns\n\nvacfOut object with VDOS data.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.adf-Tuple{Vector{MyAtoms}}","page":"API","title":"YetAnotherSimulationSuite.adf","text":"Compute the angular distribution function (ADF) between molecular orientations.\n\nArguments\n\nbdys::Vector{MyAtoms}: Vector of MyAtoms objects.\nkwargs...: Additional keyword arguments for kde_lscv.\n\nReturns\n\n(x, y): Tuple of angle values (in degrees) and ADF.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.animateMode-Tuple{Vector{MyAtoms}, Any, Any}","page":"API","title":"YetAnotherSimulationSuite.animateMode","text":"animateMode(bdys::Vector{MyAtoms}, mode, fileName; c=1.0)\n\nAnimate a vibrational mode and write the trajectory to a file.\n\nArguments\n\nbdys: Vector of MyAtoms objects.\nmode: Mode vector to animate.\nfileName: Output file name.\nc: (Optional) Amplitude scaling factor (default: 1.0).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.atomForces-Tuple{Any, Any}","page":"API","title":"YetAnotherSimulationSuite.atomForces","text":"atomForces(frame, i)\n\nGet the force vector for atom i in the given frame.\n\nArguments\n\nframe: Chemfiles Frame object.\ni: Atom index.\n\nReturns\n\nStatic vector of forces.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.center!-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.center!","text":"center!(cell)\n\nCenter the atoms in a cell.\n\nArguments\n\ncell: MyCell object.\n\nSide Effects\n\nModifies the cell in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.center-Tuple{Vector{MyAtoms}}","page":"API","title":"YetAnotherSimulationSuite.center","text":"center(bdys::Vector{MyAtoms})\n\nCompute the geometric center of a set of atoms.\n\nArguments\n\nbdys: Vector of MyAtoms.\n\nReturns\n\nCenter position as a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.centerBdys!-Tuple{Vector{MyAtoms}}","page":"API","title":"YetAnotherSimulationSuite.centerBdys!","text":"centerBdys!(bdys::Vector{MyAtoms})\n\nCenter a set of atoms at the origin.\n\nArguments\n\nbdys: Vector of MyAtoms.\n\nSide Effects\n\nModifies positions in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.countNearestNeighbors-Tuple{Any, Any}","page":"API","title":"YetAnotherSimulationSuite.countNearestNeighbors","text":"countNearestNeighbors(mol, bdys; rmax=4.5)\n\nCount the number of neighboring molecules within a cutoff distance.\n\nArguments\n\nmol: The molecule of interest.\nbdys: Collection of molecules to search for neighbors.\nrmax: (Optional) Cutoff distance for neighbor search (default 4.5).\n\nReturns\n\nNumber of neighboring molecules within rmax of mol.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.density-Tuple{Vector{MyAtoms}}","page":"API","title":"YetAnotherSimulationSuite.density","text":"Compute the average number density of atoms in a given set.\n\nArguments\n\nbdys::Vector{MyAtoms}: Vector of MyAtoms objects representing atoms.\n\nReturns\n\nFloat64: Average number density (atoms per unit volume) within the maximum radial extent from the center.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.density-Union{Tuple{A}, Tuple{Vector{Float64}, Vector{A}}} where A<:AbstractArray","page":"API","title":"YetAnotherSimulationSuite.density","text":"Compute the average number density for a set of positions relative to a given center.\n\nArguments\n\no::Vector{Float64}: The center point as a vector.\npts::Vector{A}: Vector of position vectors (any subtype of AbstractArray).\n\nReturns\n\nFloat64: Average number density (points per unit volume) within the maximum radial extent from the center.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.diffDotSqrt-Tuple{Any, Any}","page":"API","title":"YetAnotherSimulationSuite.diffDotSqrt","text":"diffDotSqrt(v2, v1)\n\nCompute the vector difference and its Euclidean norm between two vectors.\n\nArguments\n\nv2, v1: Input vectors.\n\nReturns\n\nTuple: (Euclidean distance, difference vector).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.distanceMatrixAnyCell-Tuple{MyCell}","page":"API","title":"YetAnotherSimulationSuite.distanceMatrixAnyCell","text":"distanceMatrixAnyCell(cell::MyCell)\n\nCompute the distance matrix for a general (possibly non-orthorhombic) cell.\n\nArguments\n\ncell: MyCell object.\n\nReturns\n\nSymmetric matrix of distances between atoms.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.distanceMatrixOrthorhombicCell-Tuple{MyCell}","page":"API","title":"YetAnotherSimulationSuite.distanceMatrixOrthorhombicCell","text":"distanceMatrixOrthorhombicCell(cell::MyCell)\n\nCompute the distance matrix for an orthorhombic cell.\n\nArguments\n\ncell: MyCell object.\n\nReturns\n\nSymmetric matrix of distances between atoms.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.doRun-Union{Tuple{A}, Tuple{T}, Tuple{MyCalc, T, T, Tuple{Float64, Float64}, YetAnotherSimulationSuite.Dynamics, A, AbstractFloat, Int64}} where {T, A}","page":"API","title":"YetAnotherSimulationSuite.doRun","text":"doRun(calc, vel, pos, tspan, simu, algo, dt, split; kwargs...)\n\nRun an MD simulation, optionally splitting into segments.\n\nArguments\n\ncalc: Calculator object.\nvel: Initial velocities.\npos: Initial positions.\ntspan: Time span tuple.\nsimu: Dynamics object.\nalgo: ODE solver algorithm.\ndt: Time step.\nsplit: Number of segments.\nkwargs: Additional keyword arguments.\n\nReturns\n\nProcessed trajectory or solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.dyn!-NTuple{6, Any}","page":"API","title":"YetAnotherSimulationSuite.dyn!","text":"dyn!(dv, v, u, p, t, calc)\n\nCompute the time derivative for MD integration.\n\nArguments\n\ndv: Output derivative.\nv: Velocities.\nu: Positions.\np: Dynamics object.\nt: Time.\ncalc: Calculator object.\n\nSide Effects\n\nModifies dv in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.fg!-Tuple{Any, Any, Any, Any, MyCalc}","page":"API","title":"YetAnotherSimulationSuite.fg!","text":"fg!(F, G, x, p, calc::MyCalc)\n\nEvaluate energy and/or forces and gradients for optimization.\n\nArguments\n\nF: If not nothing, return energy.\nG: If not nothing, fill with gradients.\nx: Coordinate vector.\np: Potential variables.\ncalc: Calculator object.\n\nReturns\n\nEnergy if F is not nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.findPeaks-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.findPeaks","text":"findPeaks(arr; min=0.0, max=1e30, width=1)\n\nFind indices of local maxima (peaks) in an array.\n\nArguments\n\narr: Array of numeric values to search for peaks.\nmin: Minimum value threshold for a peak (default: 0.0).\nmax: Maximum value threshold for a peak (default: 1e30).\nwidth: Minimum width for a peak (default: 1).\n\nReturns\n\nVector of indices where peaks are found.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.findTurningPoints-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.findTurningPoints","text":"findTurningPoints(arr)\n\nFind indices of local maxima and minima (turning points) in an array.\n\nArguments\n\narr: Array of numeric values.\n\nReturns\n\nVector of indices where turning points are found.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getAngle-Tuple{Any, Any}","page":"API","title":"YetAnotherSimulationSuite.getAngle","text":"getAngle(r1, r2)\n\nCompute the angle (in radians) between two vectors.\n\nArguments\n\nr1, r2: Input vectors.\n\nReturns\n\nAngle in radians.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getDiffusionCoefficient-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.getDiffusionCoefficient","text":"getDiffusionCoefficient(out; D=3)\n\nCalculate the diffusion coefficient from VACF output.\n\nArguments\n\nout: vacfOut object.\nD: Dimensionality (default: 3).\n\nReturns\n\nDiffusion coefficient (Float64).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getDistanceMatrix-Tuple{MyCell}","page":"API","title":"YetAnotherSimulationSuite.getDistanceMatrix","text":"getDistanceMatrix(cell::MyCell)\n\nCompute the pairwise distance matrix for atoms in a cell, accounting for periodicity.\n\nArguments\n\ncell: MyCell object.\n\nReturns\n\nSymmetric matrix of distances between atoms.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getForces-Tuple{MyCalc, MyCell}","page":"API","title":"YetAnotherSimulationSuite.getForces","text":"getForces(calc::MyCalc, cell::MyCell)\n\nCompute the forces on all atoms in a cell using a calculator.\n\nArguments\n\ncalc: Calculator object.\ncell: MyCell object.\n\nReturns\n\nVector of force vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getForces-Tuple{MyCalc, Vector{MyAtoms}}","page":"API","title":"YetAnotherSimulationSuite.getForces","text":"getForces(calc::MyCalc, bdys::Vector{MyAtoms})\n\nCompute the forces on a set of atoms using a calculator.\n\nArguments\n\ncalc: Calculator object.\nbdys: Vector of MyAtoms objects.\n\nReturns\n\nVector of force vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getHarmonicFreqs-Tuple{MyCalc, Union{MyCell, Vector{MyAtoms}}}","page":"API","title":"YetAnotherSimulationSuite.getHarmonicFreqs","text":"getHarmonicFreqs(calc::MyCalc, obj::Union{MyCell, Vector{MyAtoms}})\n\nCompute harmonic vibrational frequencies and modes for a cell or molecule.\n\nArguments\n\ncalc: Calculator object (MyCalc).\nobj: MyCell or vector of MyAtoms.\n\nReturns\n\nTuple: (vector of frequencies, matrix of modes).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getIPR-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.getIPR","text":"getIPR(modes; N=2)\n\nCompute the inverse participation ratio (IPR) for vibrational modes.\n\nArguments\n\nmodes: Matrix of mode vectors.\nN: Number of atoms per molecule (default: 2).\n\nReturns\n\nMatrix of IPR values.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getImage-Tuple{SciMLBase.ODESolution, Int64, Float64}","page":"API","title":"YetAnotherSimulationSuite.getImage","text":"getImage(solu::SciMLBase.ODESolution, i::Int, dt::Float64)\n\nExtract an Image from an ODE solution at a given index.\n\nArguments\n\nsolu: ODE solution object.\ni: Index of the time step.\ndt: Time step size.\n\nReturns\n\nImage object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getModePES-Tuple{MyCalc, Union{MyCell, Vector{MyAtoms}}, Any}","page":"API","title":"YetAnotherSimulationSuite.getModePES","text":"getModePES(EoM, bdys, mode; range=collect(-1:0.001:2))\n\nCompute the potential energy surface (PES) along a vibrational mode.\n\nArguments\n\ncalc: Calculator object (MyCalc).\nobj: MyCell or vector of MyAtoms.\nmode: Mode vector.\nrange: (Optional) Range of displacements (default: -1:0.001:2).\n\nReturns\n\nTuple: (range, energy values).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getMols-Tuple{MyCell, Float64}","page":"API","title":"YetAnotherSimulationSuite.getMols","text":"getMols(cell::MyCell, rmax::Float64)\n\nCluster atoms in a cell into molecules using DBSCAN with cutoff rmax.\n\nArguments\n\ncell: MyCell object.\nrmax: Distance cutoff for clustering.\n\nReturns\n\nVector of vectors, each containing indices of atoms in a molecule.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getMols-Tuple{Vector{MyAtoms}, Float64}","page":"API","title":"YetAnotherSimulationSuite.getMols","text":"getMols(bdys::Vector{MyAtoms}, rmax::Float64)\n\nCluster atoms in bdys into molecules using DBSCAN with cutoff rmax.\n\nArguments\n\nbdys: Vector of MyAtoms objects.\nrmax: Distance cutoff for clustering.\n\nReturns\n\nVector of vectors, each containing indices of atoms in a molecule.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getNewBdys-Tuple{Any, Any}","page":"API","title":"YetAnotherSimulationSuite.getNewBdys","text":"getNewBdys(bdys, res)\n\nConstruct new atom objects from optimization results.\n\nArguments\n\nbdys: Original vector of MyAtoms.\nres: Optimization result.\n\nReturns\n\nVector of new MyAtoms objects.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getNumericalStress-Tuple{MyCalc, MyCell}","page":"API","title":"YetAnotherSimulationSuite.getNumericalStress","text":"getNumericalStress(calc::MyCalc, cell::MyCell; eps=1e-6)\n\nCompute the numerical stress tensor for a cell using finite differences.\n\nArguments\n\ncalc: Calculator object (MyCalc).\ncell: Cell object (MyCell).\neps: Strain increment for finite difference (default: 1e-6).\n\nReturns\n\n3x3 stress tensor matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getNumericalStressOrthogonal-Tuple{MyCalc, MyCell}","page":"API","title":"YetAnotherSimulationSuite.getNumericalStressOrthogonal","text":"getNumericalStressOrthogonal(calc::MyCalc, cell::MyCell; eps=1e-6)\n\nCompute the numerical stress tensor for a cell using finite differences, only for diagonal terms (orthogonal cell).\n\nArguments\n\ncalc: Calculator object (MyCalc).\ncell: Cell object (MyCell).\neps: Strain increment for finite difference (default: 1e-6).\n\nReturns\n\n3x3 stress tensor matrix (only diagonal terms are nonzero).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getPR-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.getPR","text":"getPR(ipr; x=1.6e-5)\n\nCompute the participation ratio (PR) from IPR data.\n\nArguments\n\nipr: IPR matrix.\nx: Threshold value (default: 1.6e-5).\n\nReturns\n\nVector of participation ratios.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getPos-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.getPos","text":"getPos(cell)\n\nGet Cartesian positions from scaled positions in a cell.\n\nArguments\n\ncell: MyCell object.\n\nReturns\n\nVector of Cartesian positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getPotEnergy-Tuple{MyCalc, Union{MyCell, Vector{MyAtoms}}}","page":"API","title":"YetAnotherSimulationSuite.getPotEnergy","text":"getPotEnergy(calc::MyCalc, obj::Union{MyCell, Vector{MyAtoms}})\n\nCompute the potential energy of a cell or molecule.\n\nArguments\n\ncalc: Calculator object (MyCalc).\nobj: MyCell or vector of MyAtoms.\n\nReturns\n\nPotential energy (Float64).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getRdf-Tuple{Any, Any}","page":"API","title":"YetAnotherSimulationSuite.getRdf","text":"Compute the radial distribution function (RDF) from a list of distances and a density.\n\nArguments\n\nd: Array of interatomic distances.\nρ: Number density.\nkwargs...: Additional keyword arguments passed to kde_lscv.\n\nReturns\n\n(x, y): Tuple of radius values x and normalized RDF values y.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getRotEnergy-Tuple{Vector{MyAtoms}}","page":"API","title":"YetAnotherSimulationSuite.getRotEnergy","text":"getRotEnergy(mol::Vector{MyAtoms})\n\nCompute the rotational kinetic energy of a molecule.\n\nArguments\n\nmol: Vector of MyAtoms.\n\nReturns\n\nRotational energy (Float64).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getRotationMatrix-Union{Tuple{F}, Tuple{F, F, F}} where F<:AbstractFloat","page":"API","title":"YetAnotherSimulationSuite.getRotationMatrix","text":"getRotationMatrix(α::F, β::F, γ::F) where F <: AbstractFloat\n\nConstruct a rotation matrix from Euler angles (α, β, γ).\n\nArguments\n\nα, β, γ: Euler angles in radians.\n\nReturns\n\n3x3 rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getScaledPos!-Tuple{Any, Any}","page":"API","title":"YetAnotherSimulationSuite.getScaledPos!","text":"getScaledPos!(cell, x0)\n\nUpdate scaled positions in a cell from Cartesian coordinates.\n\nArguments\n\ncell: MyCell object.\nx0: Cartesian coordinates.\n\nSide Effects\n\nModifies the cell in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getScaledPos-Tuple{Any, Any}","page":"API","title":"YetAnotherSimulationSuite.getScaledPos","text":"getScaledPos(x0, lattice)\n\nGet scaled positions from Cartesian coordinates and lattice.\n\nArguments\n\nx0: Cartesian coordinates.\nlattice: Lattice matrix.\n\nReturns\n\nVector of scaled positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getScaledPos-Tuple{Vector{MyAtoms}, Any}","page":"API","title":"YetAnotherSimulationSuite.getScaledPos","text":"getScaledPos(bdys::Vector{MyAtoms}, lattice)\n\nGet scaled positions for a set of atoms given a lattice.\n\nArguments\n\nbdys: Vector of MyAtoms.\nlattice: Lattice matrix.\n\nReturns\n\nVector of scaled positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getSurfaceMolecules-Tuple{Vector{MyAtoms}}","page":"API","title":"YetAnotherSimulationSuite.getSurfaceMolecules","text":"getSurfaceMolecules(bdys::Vector{MyAtoms}; α=nothing)\n\nGet the surface molecules from a set of atoms using alpha shapes.\n\nArguments\n\nbdys: Vector of MyAtoms.\nα: Alpha parameter (optional).\n\nReturns\n\nVector of surface MyAtoms.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getTransEnergy-Tuple{Vector{MyAtoms}}","page":"API","title":"YetAnotherSimulationSuite.getTransEnergy","text":"getTransEnergy(mol::Vector{MyAtoms})\n\nCompute the translational kinetic energy of a molecule.\n\nArguments\n\nmol: Vector of MyAtoms.\n\nReturns\n\nTranslational energy (Float64).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getVelMas-Tuple{MyTraj}","page":"API","title":"YetAnotherSimulationSuite.getVelMas","text":"getVelMas(tj::MyTraj)\n\nGet all velocities and masses from a trajectory.\n\nArguments\n\ntj: Traj object.\n\nReturns\n\nTuple: (vector of velocities, vector of masses)\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getVibEnergy-Tuple{Vector{MyAtoms}, Any}","page":"API","title":"YetAnotherSimulationSuite.getVibEnergy","text":"getVibEnergy(mol::Vector{MyAtoms}, eignvec; calc=nothing)\n\nCompute the vibrational energy of a molecule along a mode.\n\nArguments\n\nmol: Vector of MyAtoms.\neignvec: Mode vector.\ncalc: (Optional) Calculator for potential energy.\n\nReturns\n\nVibrational energy (Float64).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.getVolume-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.getVolume","text":"getVolume(cell)\n\nCompute the volume of a cell.\n\nArguments\n\ncell: MyCell object.\n\nReturns\n\nVolume (Float64).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.hiddenEoM-Tuple{Any, Any, Any, MyCalc, Any, Any}","page":"API","title":"YetAnotherSimulationSuite.hiddenEoM","text":"hiddenEoM(F, G, Γ, calc::MyCalc, vars, x)\n\nEnergy and gradient evaluation for hidden variable optimization.\n\nArguments\n\nF: Energy output (or nothing).\nG: Gradient output (or nothing).\nΓ: Gradient buffer.\ncalc: Calculator object.\nvars: HiddenOptVars object.\nx: Coordinate vector.\n\nReturns\n\nEnergy value if F is not nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.hiddenOpt-Tuple{MyCalc, Any, Any, Any}","page":"API","title":"YetAnotherSimulationSuite.hiddenOpt","text":"hiddenOpt(calc::MyCalc, algo, cell, T; kwargs...)\n\nOptimize a cell using a hidden variable approach and a supercell transformation.\n\nArguments\n\ncalc: Calculator object.\nalgo: Optimization algorithm.\ncell: MyCell object.\nT: Transformation matrix.\nkwargs: Additional options.\n\nReturns\n\nOptimized MyCell object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.ifProperty-Tuple{Any, Any, Any}","page":"API","title":"YetAnotherSimulationSuite.ifProperty","text":"ifProperty(frame, props, p)\n\nReturn the value of property p from frame if it exists in props, else return 0.0.\n\nArguments\n\nframe: Chemfiles Frame object.\nprops: List of property names.\np: Property name to look for.\n\nReturns\n\nValue of the property as Float64, or 0.0 if not found.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.makeBdys-Tuple{MyCell}","page":"API","title":"YetAnotherSimulationSuite.makeBdys","text":"makeBdys(cell::MyCell)::Vector{MyAtoms}\n\nConvert a cell to a vector of MyAtoms.\n\nArguments\n\ncell: MyCell object.\n\nReturns\n\nVector of MyAtoms.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.makeBdys-Tuple{MyTraj, Int64}","page":"API","title":"YetAnotherSimulationSuite.makeBdys","text":"makeBdys(tj::MyTraj, i::Int)\n\nConstruct a vector of MyAtoms from a trajectory at a given image index.\n\nArguments\n\ntj: Traj object.\ni: Image index.\n\nReturns\n\nVector of MyAtoms.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.makeCell-Tuple{Vector{MyAtoms}, AbstractMatrix}","page":"API","title":"YetAnotherSimulationSuite.makeCell","text":"makeCell(bdys, lattice; mask, PBC, NC)\n\nConstruct a Cell from a vector of MyAtoms and a lattice.\n\nArguments\n\nbdys: Vector of MyAtoms.\nlattice: Lattice matrix.\nmask: Mask vector (optional).\nPBC: Periodic boundary conditions (optional).\nNC: Neighbor counts (optional).\n\nReturns\n\nCell object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.makeSuperCell!-Tuple{Any, Any, Any}","page":"API","title":"YetAnotherSimulationSuite.makeSuperCell!","text":"makeSuperCell!(super, cell, T)\n\nIn-place creation of a supercell from a cell and transformation matrix.\n\nArguments\n\nsuper: Supercell object to fill.\ncell: Cell to replicate.\nT: Transformation matrix.\n\nSide Effects\n\nModifies the supercell in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.makeSuperCell-Tuple{Any, Any}","page":"API","title":"YetAnotherSimulationSuite.makeSuperCell","text":"makeSuperCell(cell, T)\n\nCreate a supercell from a cell and transformation matrix.\n\nArguments\n\ncell: MyCell object.\nT: Transformation matrix.\n\nReturns\n\nNew supercell object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.mirror!-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.mirror!","text":"mirror!(out)\n\nMirror the VACF output for improved frequency resolution.\n\nArguments\n\nout: vacfOut object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.mkvar-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.mkvar","text":"mkvar(x)\n\nEvaluate a symbol from a string and return its value.\n\nArguments\n\nx: String representing the variable name.\n\nReturns\n\nValue of the variable with name x.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.myRepeat-Union{Tuple{D}, Tuple{Array{StaticArraysCore.MVector{D, Float64}, 1}, Integer, Vector{Bool}}} where D","page":"API","title":"YetAnotherSimulationSuite.myRepeat","text":"myRepeat(A::Vector{MVector{D,Float64}}, count::Integer, mask::Vector{Bool}) where D\n\nRepeat elements of a vector of static vectors, excluding masked elements, and return a deep copy.\n\nArguments\n\nA: Vector of MVector{D,Float64}.\ncount: Number of times to repeat unmasked elements.\nmask: Boolean mask vector (true = keep, false = repeat).\n\nReturns\n\nVector of repeated and copied static vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.myRepeat-Union{Tuple{T}, Tuple{Vector{T}, Integer, Vector{Bool}}} where T<:Union{Number, String}","page":"API","title":"YetAnotherSimulationSuite.myRepeat","text":"myRepeat(A::Vector{T}, count::Integer, mask::Vector{Bool}) where T <: Union{String, Number}\n\nRepeat elements of a vector, excluding masked elements, and concatenate with the original.\n\nArguments\n\nA: Input vector.\ncount: Number of times to repeat unmasked elements.\nmask: Boolean mask vector (true = keep, false = repeat).\n\nReturns\n\nConcatenated vector with repeated elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.opt-Tuple{MyCalc, Any, MyCell}","page":"API","title":"YetAnotherSimulationSuite.opt","text":"opt(calc::MyCalc, algo, cell::MyCell; kwargs...)\n\nOptimize the geometry of a cell.\n\nArguments\n\ncalc: Calculator object.\nalgo: Optimization algorithm.\ncell: MyCell object.\nkwargs: Additional options.\n\nReturns\n\nOptimized MyCell object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.opt-Tuple{MyCalc, Any, Vector{MyAtoms}}","page":"API","title":"YetAnotherSimulationSuite.opt","text":"opt(calc::MyCalc, algo, bdys::Vector{MyAtoms}; kwargs...)\n\nOptimize the geometry of a set of atoms.\n\nArguments\n\ncalc: Calculator object.\nalgo: Optimization algorithm.\nbdys: Vector of MyAtoms objects.\nkwargs: Additional options.\n\nReturns\n\nOptimized vector of MyAtoms.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.optCell-Tuple{MyCalc, Any, MyCell}","page":"API","title":"YetAnotherSimulationSuite.optCell","text":"optCell(calc::MyCalc, algo, cell::MyCell; precon=nothing, kwargs...)\n\nOptimize the lattice parameters of a cell.\n\nArguments\n\ncalc: Calculator object.\nalgo: Optimization algorithm.\ncell: MyCell object.\nprecon: (Optional) Preconditioner.\nkwargs: Additional options.\n\nReturns\n\nOptimized MyCell object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.periodicDistance-Tuple{AbstractArray, AbstractArray, Any}","page":"API","title":"YetAnotherSimulationSuite.periodicDistance","text":"periodicDistance(x::AbstractArray, y::AbstractArray, vects)\n\nCompute the minimum periodic distance between two points given lattice vectors.\n\nArguments\n\nx, y: Position vectors.\nvects: Iterable of lattice vectors.\n\nReturns\n\nMinimum periodic distance (Float64).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.pickRandomMol-Tuple{Vector{MyAtoms}, Any}","page":"API","title":"YetAnotherSimulationSuite.pickRandomMol","text":"pickRandomMol(bdys::Vector{MyAtoms}, loc)\n\nPick a random molecule from the surface or bulk.\n\nArguments\n\nbdys: Vector of MyAtoms.\nloc: \"surf\" or \"bulk\".\n\nReturns\n\nVector of MyAtoms for the selected molecule.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.prep4pot-Tuple{Any, MyCell}","page":"API","title":"YetAnotherSimulationSuite.prep4pot","text":"prep4pot(builder, cell::MyCell)\n\nPrepare variables for potential energy calculation from a cell.\n\nArguments\n\nbuilder: Potential builder function.\ncell: MyCell object.\n\nReturns\n\nTuple: (coordinate vector, optVars object).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.prep4pot-Tuple{Any, Vector{MyAtoms}}","page":"API","title":"YetAnotherSimulationSuite.prep4pot","text":"prep4pot(builder, bdys::Vector{MyAtoms})\n\nPrepare variables for potential energy calculation from atoms.\n\nArguments\n\nbuilder: Potential builder function.\nbdys: Vector of MyAtoms objects.\n\nReturns\n\nTuple: (coordinate vector, optVars object).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.prepX0-Tuple{MyCell}","page":"API","title":"YetAnotherSimulationSuite.prepX0","text":"prepX0(cell::MyCell)\n\nPrepare the initial coordinate vector from a cell.\n\nArguments\n\ncell: MyCell object.\n\nReturns\n\nFlat vector of coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.prepX0-Tuple{Vector{MyAtoms}}","page":"API","title":"YetAnotherSimulationSuite.prepX0","text":"prepX0(bdys::Vector{MyAtoms})\n\nPrepare the initial coordinate vector from a set of atoms.\n\nArguments\n\nbdys: Vector of MyAtoms objects.\n\nReturns\n\nFlat vector of coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.processDynamics-Tuple{SciMLBase.ODESolution, Float64}","page":"API","title":"YetAnotherSimulationSuite.processDynamics","text":"processDynamics(solu::SciMLBase.ODESolution; dt=fs, step=1)\n\nConvert an ODE solution to a Traj object.\n\nArguments\n\nsolu: ODE solution object.\ndt: Time step (default: fs).\nstep: Step interval (default: 1).\n\nReturns\n\nTraj object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.processTmpFiles-Tuple{Any, Any}","page":"API","title":"YetAnotherSimulationSuite.processTmpFiles","text":"processTmpFiles(files; kwargs...)\n\nProcess a list of temporary files containing ODE solutions into a single trajectory.\n\nArguments\n\nfiles: List of file paths.\nkwargs: Additional keyword arguments.\n\nReturns\n\nTraj object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.randRotate!-Tuple{Vector{MyAtoms}, Vector{Float64}}","page":"API","title":"YetAnotherSimulationSuite.randRotate!","text":"randRotate!(bdys::Vector{MyAtoms}, about::Vector{Float64})\n\nApply a random rotation about a point about to all atoms in bdys in-place.\n\nArguments\n\nbdys: Vector of MyAtoms objects.\nabout: Point to rotate about.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.randRotate!-Tuple{Vector{MyAtoms}}","page":"API","title":"YetAnotherSimulationSuite.randRotate!","text":"randRotate!(bdys::Vector{MyAtoms})\n\nApply a random rotation to all atoms in bdys in-place.\n\nArguments\n\nbdys: Vector of MyAtoms objects.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.rdf-Tuple{Vector{MyAtoms}, Pair{String, String}}","page":"API","title":"YetAnotherSimulationSuite.rdf","text":"Compute the radial distribution function for pairs of two specified atomic species.\n\nArguments\n\nbdys::Vector{MyAtoms}: Vector of MyAtoms objects.\nP::Pair{String, String}: Pair of atomic species labels (A, B).\nkwargs...: Additional keyword arguments for getRdf.\n\nReturns\n\n(x, y): Tuple of radius values and RDF for the species pair.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.rdf-Tuple{Vector{MyAtoms}, String}","page":"API","title":"YetAnotherSimulationSuite.rdf","text":"Compute the radial distribution function for all pairs of a given atomic species.\n\nArguments\n\nbdys::Vector{MyAtoms}: Vector of MyAtoms objects.\nA::String: Atomic species label.\nkwargs...: Additional keyword arguments for getRdf.\n\nReturns\n\n(x, y): Tuple of radius values and RDF for the given species.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.rdf-Tuple{Vector{MyAtoms}}","page":"API","title":"YetAnotherSimulationSuite.rdf","text":"Compute the radial distribution function between molecular centers of mass.\n\nArguments\n\nbdys::Vector{MyAtoms}: Vector of MyAtoms objects.\nrmol: Distance threshold for molecular grouping (default 1.2).\nkwargs...: Additional keyword arguments for getRdf.\n\nReturns\n\n(x, y): Tuple of radius values and RDF.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.readFrame-Tuple{Chemfiles.Frame}","page":"API","title":"YetAnotherSimulationSuite.readFrame","text":"readFrame(frame::Frame)\n\nConvert a Chemfiles Frame to a vector of MyAtoms or a MyCell if lattice is present.\n\nArguments\n\nframe: Chemfiles Frame object.\n\nReturns\n\nVector of MyAtoms or MyCell object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.readImage-Tuple{Chemfiles.Frame}","page":"API","title":"YetAnotherSimulationSuite.readImage","text":"readImage(frame::Frame)\n\nRead an image (snapshot) from a Chemfiles Frame, extracting positions, velocities, forces, and properties.\n\nArguments\n\nframe: Chemfiles Frame object.\n\nReturns\n\nImage object containing positions, velocities, time, temperature, energy, and forces.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.readSystem-Tuple{String}","page":"API","title":"YetAnotherSimulationSuite.readSystem","text":"readSystem(file::String)\n\nRead a system from a file and return either a trajectory or a single frame.\n\nArguments\n\nfile: Path to the file.\n\nReturns\n\nTraj object if multiple frames, otherwise a single frame as MyCell or MyAtoms.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.readTraj-Tuple{Chemfiles.Trajectory, Int64}","page":"API","title":"YetAnotherSimulationSuite.readTraj","text":"readTraj(buf::Trajectory, N::Int)\n\nRead a trajectory from a Chemfiles Trajectory buffer.\n\nArguments\n\nbuf: Chemfiles Trajectory object.\nN: Number of frames to read.\n\nReturns\n\nTraj object containing all images, masses, symbols, and lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.reducedMass-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.reducedMass","text":"reducedMass(bdys)\n\nCompute the reduced mass for a collection of atoms.\n\nArguments\n\nbdys: Vector of objects with field m (mass).\n\nReturns\n\nReduced mass (Float64).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.reducedMass-Tuple{Vector{Float64}}","page":"API","title":"YetAnotherSimulationSuite.reducedMass","text":"reducedMass(mas::Vector{Float64})\n\nCompute the reduced mass from a vector of masses.\n\nArguments\n\nmas: Vector of masses.\n\nReturns\n\nReduced mass (Float64).\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.reorder!-Tuple{MyCell, Vector{Int64}}","page":"API","title":"YetAnotherSimulationSuite.reorder!","text":"reorder!(cell::MyCell, order::Vector{Int})\n\nReorder the atoms in a cell according to a given order.\n\nArguments\n\ncell: MyCell object.\norder: New order of indices.\n\nSide Effects\n\nModifies the cell in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.replicate!-Tuple{Any, Any, Any}","page":"API","title":"YetAnotherSimulationSuite.replicate!","text":"replicate!(super, cell, N)\n\nReplicate a cell into a supercell.\n\nArguments\n\nsuper: Supercell object to fill.\ncell: Cell to replicate.\nN: Replication factors along each axis.\n\nSide Effects\n\nModifies the supercell in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.savGol-Tuple{Any, Any, Any}","page":"API","title":"YetAnotherSimulationSuite.savGol","text":"savGol(y, ws, order; deriv=0)\n\nApply a Savitzky-Golay filter to the input signal y.\n\nArguments\n\ny: Array of data points to be smoothed or differentiated.\nws: Window size (must be odd and ≥ 1).\norder: Polynomial order for the filter (must satisfy ws ≥ order + 2).\nderiv: (Optional) Order of the derivative to compute (default is 0, i.e., smoothing).\n\nReturns\n\nFiltered (or differentiated) signal as an array of the same length as y.\n\nThrows\n\nArgumentError if input arguments are invalid.\n\nExample\n\nsmoothed = savGol(data, 5, 2)\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.singleRun-Union{Tuple{A}, Tuple{T}, Tuple{MyCalc, T, T, Tuple{Float64, Float64}, YetAnotherSimulationSuite.Dynamics, A, AbstractFloat}} where {T, A}","page":"API","title":"YetAnotherSimulationSuite.singleRun","text":"singleRun(calc, vel, pos, tspan, simu, algo, dt; kwargs...)\n\nRun a single MD simulation segment.\n\nArguments\n\ncalc: Calculator object.\nvel: Initial velocities.\npos: Initial positions.\ntspan: Time span tuple.\nsimu: Dynamics object.\nalgo: ODE solver algorithm.\ndt: Time step.\nkwargs: Additional keyword arguments.\n\nReturns\n\nODE solution object.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.st!-Tuple{Any, Any, Any, MyCell, MyCalc}","page":"API","title":"YetAnotherSimulationSuite.st!","text":"st!(F, G, x, cell::MyCell, calc::MyCalc; precon=nothing, diag=false)\n\nEvaluate stress and/or energy for cell optimization.\n\nArguments\n\nF: If not nothing, return energy.\nG: If not nothing, fill with gradients.\nx: Lattice vector.\ncell: MyCell object.\ncalc: Calculator object.\nprecon: Preconditioner (optional).\ndiag: Use only diagonal terms (default: false).\n\nReturns\n\nEnergy if F is not nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.swapAtoms!-Tuple{Vector{MyAtoms}, Any, Any}","page":"API","title":"YetAnotherSimulationSuite.swapAtoms!","text":"swapAtoms!(bdys::Vector{MyAtoms}, i, j)\n\nSwap the positions of two atoms in a vector.\n\nArguments\n\nbdys: Vector of MyAtoms.\ni: Index of first atom.\nj: Index of second atom.\n\nSide Effects\n\nModifies the positions in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.swapIso!-Tuple{Vector{MyAtoms}, Any, Any}","page":"API","title":"YetAnotherSimulationSuite.swapIso!","text":"swapIso!(bdys::Vector{MyAtoms}, swap, mas)\n\nSwap isotopes (masses) for a set of atoms.\n\nArguments\n\nbdys: Vector of MyAtoms.\nswap: Indices to swap.\nmas: New masses.\n\nSide Effects\n\nModifies masses in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.transExcite!-Tuple{Vector{MyAtoms}, Any}","page":"API","title":"YetAnotherSimulationSuite.transExcite!","text":"transExcite!(mol::Vector{MyAtoms}, ke)\n\nExcite the translational motion of a molecule to a given kinetic energy.\n\nArguments\n\nmol: Vector of MyAtoms.\nke: Target kinetic energy.\n\nSide Effects\n\nModifies velocities of atoms in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.translate!-Tuple{Vector{MyAtoms}, Vector{Float64}}","page":"API","title":"YetAnotherSimulationSuite.translate!","text":"translate!(bdys::Vector{MyAtoms}, v::Vector{Float64})\n\nTranslate all atoms in bdys by vector v in-place.\n\nArguments\n\nbdys: Vector of MyAtoms objects.\nv: Translation vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.vCoM-Tuple{Any, Any}","page":"API","title":"YetAnotherSimulationSuite.vCoM","text":"vCoM(vel, mas)\n\nCompute the center of mass velocity from velocities and masses.\n\nArguments\n\nvel: Vector of velocity vectors.\nmas: Vector of masses.\n\nReturns\n\nCenter of mass velocity as a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.vCoM-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.vCoM","text":"vCoM(bdys)\n\nCompute the center of mass velocity for a collection of atoms.\n\nArguments\n\nbdys: Vector of objects with fields m (mass) and v (velocity).\n\nReturns\n\nCenter of mass velocity as a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.vacf!-Tuple{Any, Any}","page":"API","title":"YetAnotherSimulationSuite.vacf!","text":"vacf!(inp, out; atms=nothing)\n\nCompute the velocity autocorrelation function (VACF).\n\nArguments\n\ninp: vacfInps object.\nout: vacfOut object.\natms: (Optional) Indices of atoms to include.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.vibExcite!-Tuple{Vector{MyAtoms}, Any, Any}","page":"API","title":"YetAnotherSimulationSuite.vibExcite!","text":"vibExcite!(mol::Vector{MyAtoms}, eignvec, E)\n\nExcite a vibrational mode of a molecule to a given energy.\n\nArguments\n\nmol: Vector of MyAtoms.\neignvec: Mode vector.\nE: Target energy.\n\nSide Effects\n\nModifies velocities of atoms in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.window!-Tuple{Any, Any}","page":"API","title":"YetAnotherSimulationSuite.window!","text":"window!(out, W)\n\nApply a window function to the VACF output.\n\nArguments\n\nout: vacfOut object.\nW: Window function.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.wrap!-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.wrap!","text":"wrap!(cell)\n\nWrap all atoms in a cell into the primary unit cell.\n\nArguments\n\ncell: MyCell object.\n\nSide Effects\n\nModifies the cell in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.wrap!-Tuple{Vector{MyAtoms}, Any}","page":"API","title":"YetAnotherSimulationSuite.wrap!","text":"wrap!(bdys::Vector{MyAtoms}, lattice)\n\nWrap all atoms into the primary unit cell.\n\nArguments\n\nbdys: Vector of MyAtoms.\nlattice: Lattice matrix.\n\nSide Effects\n\nModifies positions in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#YetAnotherSimulationSuite.zeroVCoM!-Tuple{Any}","page":"API","title":"YetAnotherSimulationSuite.zeroVCoM!","text":"zeroVCoM!(bdys)\n\nRemove the center of mass velocity from a collection of atoms in-place.\n\nArguments\n\nbdys: Vector of objects with fields m (mass) and v (velocity).\n\nSide Effects\n\nModifies velocities in-place to set total momentum to zero.\n\n\n\n\n\n","category":"method"},{"location":"memory/#Memory-Considerations","page":"Memory Considerations","title":"Memory Considerations","text":"Currently, YASS has a roughly 1 GB memory overhead due to dependencies, buffer allocations, and compilation artifacts. This overhead is typical for Julia packages with similar functionality, but may be significant for users with limited memory resources. This overhead is static and does not scale with system size, so larger simulations will see a smaller relative impact. Future optimizations may reduce this overhead.\n\nA few examples of memory usage for different system sizes are provided below, the systems were those used in the benchmark section.","category":"section"},{"location":"memory/#Geometry-Optimization","page":"Memory Considerations","title":"Geometry Optimization","text":"Number of Atoms Iterations Memory Usage (GB)\n100 1500 1.06\n500 1500 1.06\n1000 1500 1.06","category":"section"},{"location":"memory/#Harmonic-Frequency-Calculation","page":"Memory Considerations","title":"Harmonic Frequency Calculation","text":"Number of Atoms Memory Usage (GB)\n100 1.07\n500 1.16\n1000 1.41","category":"section"},{"location":"memory/#Molecular-Dynamics-Simulation","page":"Memory Considerations","title":"Molecular Dynamics Simulation","text":"Number of Atoms Time Steps Memory Usage (GB)\n100 1000 1.12\n500 1000 1.15\n1000 1000 1.19\n5000 1000 1.55","category":"section"},{"location":"benchmark/#Benchmark","page":"Benchmark","title":"Benchmark","text":"","category":"section"},{"location":"benchmark/#Disclaimer","page":"Benchmark","title":"Disclaimer","text":"Julia often delivers substantial performance gains over Python for numerical and scientific code because it is JIT‑compiled, type‑stable, and generates native LLVM code, so well‑written Julia can approach C/Fortran speeds. However, that speed comes with trade‑offs: just‑in‑time compilation (and package precompilation) introduces startup latency, and Julia’s compilation artifacts and runtime can consume more memory than lightweight Python interpreters. In practice, Julia is most advantageous for long‑running, compute‑intensive workflows; for short scripts or very memory‑constrained environments you should weigh the startup and memory overheads or use precompilation strategies to mitigate them.","category":"section"},{"location":"benchmark/#Benchmark-Setup","page":"Benchmark","title":"Benchmark Setup","text":"All files used in the benchmark can be found in the GitHub repo under the benchmarks/ directory. All benchmarks were run using an AMD Ryzen 9 3950X 16-Core Processor with 64 GB of RAM running Fedora 43. ","category":"section"},{"location":"benchmark/#Benchmark-Results","page":"Benchmark","title":"Benchmark Results","text":"YetAnotherSimulationSuite.jl (YASS) was benchmarked against Atomistic Simulation Environment (ASE) for geometry optimization, harmonic frequency calculations, and molecular dynamics simulations. For both packages, a simple Lennard-Jones potential for gold atoms was used. The results are shown below.\n\nIn all cases, YASS outperforms ASE once the computational workload is sufficiently large to overcome YASS's initial compilation overhead. The speedups observed can still increase further for longer-running simulations.","category":"section"},{"location":"benchmark/#Geometry-Optimization","page":"Benchmark","title":"Geometry Optimization","text":"Geometry optimizations using the LBFGS algorithm were performed on gold clusters containing 100, 500, 1000, and 5000 atoms. The results are shown in the table below.\n\nNumber of Atoms Iterations YASS Time (s) ASE Time (s) YASS Speedup\n100 1500 11.8 8.4 0.71x\n500 1500 29.6 64.0 2.16x\n1000 1500 108.7 218.8 2.01x","category":"section"},{"location":"benchmark/#Harmonic-Frequencies","page":"Benchmark","title":"Harmonic Frequencies","text":"Harmonic frequency calculations were performed on gold clusters containing 100, 500, and 1000 atoms. The results are shown in the table below.\n\nNumber of Atoms YASS Time (s) ASE Time (s) YASS Speedup\n100 11.2 3.3 0.29x\n500 22.7 89.8 3.95x\n1000 87.1 490.8 5.63x","category":"section"},{"location":"benchmark/#Molecular-Dynamics","page":"Benchmark","title":"Molecular Dynamics","text":"Molecular dynamics simulations were performed on gold clusters containing 100, 500, and 1000 atoms for 1000, 2000 and 5000 time steps. The results are shown in the table below.\n\nNumber of Atoms Time Steps YASS Time (s) ASE Time (s) YASS Speedup\n100 1000 15.8 4.8 0.30x\n100 2000 16.1 9.3 0.58x\n100 5000 16.6 22.4 1.35x\n500 1000 21.9 32.3 1.47x\n500 2000 27.7 65.9 2.38x\n500 5000 44.2 160.7 3.63x\n1000 1000 35.6 79.4 2.23x\n1000 2000 55.9 165.3 2.95x\n1000 5000 112.5 406.1 3.61x\n1000 15000 315.3 1332.8 4.22x","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"warning: YetAnotherSimulationSuite.jl is still very early in its development\nThis package is still very early in its development, and there are more mature molecular dynamics packages in Julia. For instance, Molly.jl and NQCDynamics.jl both offer molecular dyanmics in Julia.\n\nYetAnotherSimulationSuite.jl (YASS) aims to offer users a simple, intuitive and easy-to-use molecular dynamics enviornment. It draws inspiration from Python's ASE, but is intended to be faster and offer users more flexibility. The flexibility comes from the relative ease with which users can add their own methods to dynamics or other components of YASS.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"YASS can be installed using the Julia package manger via:\n\npkg> add YetAnotherSimulationSuite\n\nIf you are more adventerous, you can consider installing YASS from GitHub. This will get updates more frequently, which gives users more features but also comes with increased chances of bugs. \n\npkg> add https://github.com/Cavenfish/YetAnotherSimulationSuite.jl","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Currently, YASS is able to perform the following simulations/calculations on molecular systems.\n\nGeometry optimizations\nHarmonic frequency calculations\nClassical molecular dynamics in the NVE and NVT ensemble","category":"section"},{"location":"md/dynamics/#Molecular-Dynamics-Simulations","page":"Molecular Dynamics Simulations","title":"Molecular Dynamics Simulations","text":"YASS provides functionality for classical molecular dynamics simulations in different ensembles. This guide explains how to set up and run MD simulations.","category":"section"},{"location":"md/dynamics/#Basic-Usage","page":"Molecular Dynamics Simulations","title":"Basic Usage","text":"The simplest way to run an MD simulation is in the NVE (microcanonical) ensemble:\n\nusing YetAnotherSimulationSuite\n\n# Read initial structure\nwater = readSystem(\"water.xyz\")\n\n# Create NVE ensemble\nensemble = NVE()\n\n# Run 5 picosecond simulation with 0.1 fs timestep\ntraj = run(TIP4Pf(), water, 5u\"ps\", 0.1u\"fs\", ensemble)\n\n# You can also specify the start time\ntraj = run(TIP4Pf(), water, (5u\"ps\", 10u\"ps\"), 0.1u\"fs\", ensemble)\n\nThe run function takes the following arguments:\n\nCalculator (force field)\nInitial structure\nTime or time span tuple (start, end)\nTime step\nEnsemble","category":"section"},{"location":"md/dynamics/#Available-Ensembles","page":"Molecular Dynamics Simulations","title":"Available Ensembles","text":"","category":"section"},{"location":"md/dynamics/#NVE-Ensemble","page":"Molecular Dynamics Simulations","title":"NVE Ensemble","text":"The NVE ensemble maintains constant number of particles (N), volume (V), and energy (E):\n\nensemble = NVE()","category":"section"},{"location":"md/dynamics/#NVT-Ensemble","page":"Molecular Dynamics Simulations","title":"NVT Ensemble","text":"The NVT ensemble maintains constant temperature using a thermostat. YASS supports several thermostats:\n\n# Thermostats need unit information from calc\ncalc = TIP4Pf()\n\n# Berendsen thermostat at 300K with 50fs coupling time\nensemble = Berendsen(300.0u\"K\", 50u\"fs\", calc) |> NVT\n\n# Cannonical velocity rescaling thermostat at 300K\nensemble = CVR(300.0u\"K\", 100u\"fs\", calc) |> NVT \n\n# Langevin thermostat at 300K with 10fs coupling time\nensemble = Langevin(300.0u\"K\", 10u\"fs\") |> NVT","category":"section"},{"location":"md/dynamics/#Working-with-Trajectories","page":"Molecular Dynamics Simulations","title":"Working with Trajectories","text":"The run function returns a Traj object containing the simulation data:\n\n# Access trajectory information\nprintln(\"Number of frames: \", length(traj))\nprintln(\"Atomic symbols: \", traj.symbols)\nprintln(\"Atomic masses: \", traj.masses)\n\n# Get positions from first frame\npos = traj.images[1].pos\n\n# Get velocities from last frame \nvel = traj.images[end].vel\n\n# Get temperature and energy arrays\ntemps = [img.temp for img in traj.images]\nenergies = [img.energy for img in traj.images]","category":"section"},{"location":"md/dynamics/#Long-Simulations","page":"Molecular Dynamics Simulations","title":"Long Simulations","text":"For longer simulations, you can split them into segments to save memory:\n\n# Run 1 nanosecond simulation split into 10 segments\ntraj = run(TIP4Pf(), water, 1u\"ns\", 1.0u\"fs\", ensemble; split=10)","category":"section"},{"location":"md/dynamics/#Saving-Trajectories","page":"Molecular Dynamics Simulations","title":"Saving Trajectories","text":"Trajectories can be saved to disk in various formats:\n\n# Save as XYZ file\nwrite(\"trajectory.xyz\", traj)\n\n# Save as JLD file (binary format)\nusing JLD2\n@save \"trajectory.jld2\" traj","category":"section"},{"location":"md/dynamics/#Periodic-Boundary-Conditions-(PBC)","page":"Molecular Dynamics Simulations","title":"Periodic Boundary Conditions (PBC)","text":"For periodic systems, read the structure as a cell:\n\n# Read periodic cell\ncell = readSystem(\"crystal.xyz\")\n\n# Run simulation with PBC\ntraj = run(calc, cell, 10u\"ps\", 1.0u\"fs\", NVE(cell))","category":"section"}]
}
